# Графы, DFS, MST

## [Задача A](a.cpp). Топологическая сортировка
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p> 

__Условие__  
Дан ориентированный невзвешенный граф. Необходимо его топологически отсортировать.

__Входные данные__  
В первой строке входного файла даны два натуральных числа $N$ и $M\ (1 ≤ N ≤ 100\ 000, 0 ≤ M ≤ 100\ 000)$ — количество вершин и рёбер в графе соответственно. Далее в $M$ строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин соответственно.

__Выходные данные__  
Вывести любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно топологически отсортировать, вывести $-1$.

__Пример__  
>__Входные данные__  
>6 6  
>1 2  
>3 2  
>4 2  
>2 5  
>6 5  
>4 6
>__Выходные данные__  
>4 6 3 1 2 5 

***

## [Задача B](b.cpp). Мосты  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>


__Условие__  
Дан неориентированный граф, не обязательно связный, но не содержащий петель и кратных рёбер. Требуется найти все мосты в нём. 

__Входные данные__  
Первая строка входного файла содержит два натуральных числа $n$ и $m$ — количества вершин и рёбер графа соответственно $(1 ≤ n ≤ 20\ 000, 1 ≤ m ≤ 200\ 000)$.  
Следующие $m$ строк содержат описание рёбер по одному на строке. Ребро номер $i$ описывается двумя натуральными числами $b_i$, $e_i$ — номерами концов ребра $(1 ≤ b_i, e_i ≤ n)$.

__Выходные данные__  
Первая строка выходного файла должна содержать одно натуральное число $b$ — количество мостов в заданном графе. На следующей строке выведите $b$ целых чисел — номера рёбер, которые являются мостами, в возрастающем порядке. Рёбра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

__Пример__  
>__Входные данные__  
>6 7  
>1 2  
>2 3  
>3 4  
>1 3  
>4 5  
>4 6  
>5 6  
>__Выходные данные__  
>1  
>3

***

## [Задача C](c.pp). Точки сочленения  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>


__Условие__  
Дан неориентированный граф. Требуется найти все точки сочленения в нём.

__Входные данные__  
Первая строка входного файла содержит два натуральных числа $n$ и $m$ — количества вершин и рёбер графа соответственно $(1 ≤ n ≤ 20\ 000, 1 ≤ m ≤ 200\ 000)$.   
Следующие $m$ строк содержат описание рёбер по одному на строке. Ребро номер $i$ описывается двумя натуральными числами $b_i$, $e_i$ — номерами концов ребра $(1 ≤ b_i, e_i ≤ n)$.

__Выходные данные__  
Первая строка выходного файла должна содержать одно натуральное число $b$ — количество точек сочленения в заданном графе. На следующей строке выведите $b$ целых чисел — номера вершин, которые являются точками сочленения, в возрастающем порядке. 

__Пример__  
>__Входные данные__  
>6 7  
>1 2  
>2 3  
>2 4  
>2 5  
>4 5  
>1 3  
>3 6  
>__Выходные данные__  
>2  
>2 3  

***

## [Задча D](d.cpp). Компоненты реберной двусвязности  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 64 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие__  
Компонентой реберной двусвязности графа называется подмножество вершин , такое что для любых различных $u$ и $v$ из этого множества существует не менее двух реберно не пересекающихся путей из $u$ в $v$.  
Дан неориентированный граф. Требуется выделить компоненты реберной двусвязности в нем.

__Входные данные__  
Первая строка входного файла содержит два натуральных числа $n$ и $m$ — количества вершин и ребер графа соответственно $(1  ≤  n  ≤  20\ 000, 1  ≤  m  ≤  200\ 000)$.  

Следующие $m$ строк содержат описание ребер по одному на строке. Ребро номер $i$ описывается двумя натуральными числами $b_i$, $e_i$ — номерами концов ребра $(1 ≤ b_i, e_i ≤ n)$.

__Выходные данные__  
В первой строке выходного файла выведите целое число $k$ — количество компонент реберной двусвязности графа. Во второй строке выведите $n$ натуральных чисел $a_1, a_2, ...\ , a_n$, не превосходящих $k$, где $a_i$ — номер компоненты реберной двусвязности, которой принадлежит $i$-я вершина.

__Пример__  
>__Входные данные__  
>6 7  
>1 2  
>2 3  
>3 1  
>1 4  
>4 5  
>4 6  
>5 6  
>__Выходные данные__  
>2  
>1 1 1 2 2 2

***

## [Задча E](e.cpp). Компоненты вершинной двусвязности  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 64 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>


__Условие__  
Компонентой вершинной двусвязности графа называется максимальный по включению подграф (состоящий из вершин и ребер), такой что любые два ребра из него лежат на вершинно простом цикле.

Дан неориентированный граф без петель. Требуется выделить компоненты вершинной двусвязности в нем.

__Входные данные__  
Первая строка входного файла содержит два натуральных числа $n$ и $m$ — количества вершин и ребер графа соответственно $(1 ≤ n ≤ 20\ 000, 1 ≤ m ≤ 200\ 000)$.

Следующие $m$ строк содержат описание ребер по одному на строке. Ребро номер $i$ описывается двумя натуральными числами $b_i$, $e_i$ — номерами концов ребра $(1 ≤ b_i, e_i ≤ n)$.

__Выходные данные__  
В первой строке выходного файла выведите целое число $k$ — количество компонент вершинной двусвязности графа. Во второй строке выведите $m$ натуральных чисел $a_1, a_2, ...\ , a_m$, не превосходящих $k$, где $a_i$ — номер компоненты вершинной двусвязности, которой принадлежит $i$-е ребро. Ребра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

__Пример__  
>__Входные данные__  
>5 6  
>1 2  
>2 3  
>3 1  
>1 4  
>4 5  
>5 1  
>__Выходные данные__  
>2  
>1 1 1 2 2 2 

***

## [Задча F](f.cpp). Конденсация графа  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие__  
Требуется найти количество ребер в конденсации ориентированного графа. Примечание: конденсация графа не содержит кратных ребер.

__Входные данные__  
Первая строка входного файла содержит два натуральных числа $n$ и $m$ — количество вершин и ребер графа соответственно $(n ≤ 10\ 000,  m ≤ 100\ 000)$. Следующие $m$ строк содержат описание ребер, по одному на строке. Ребро номер i описывается двумя натуральными числами $b_i$, $e_i$ — началом и концом ребра соответственно $(1  ≤  b_i,  e_i  ≤  n)$. В графе могут присутствовать кратные ребра и петли.

__Выходные данные__  
Единственная строка выходного файла должна содержать одно число — количество ребер в конденсации графа.

__Пример__  
>__Входные данные__  
>4 4  
>2 1  
>3 2  
>2 3  
>4 3  
>__Выходные данные__  
>2

***

## [Задча G](g.cpp). Планирование вечеринки   
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 512 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>

__Условие__  
Петя планирует вечеринку, это дело непростое. Одна из главных проблем в том, что некоторые его друзья плохо ладят друг с другом, а некоторые — наоборот. В результате у него есть множество требований, например: «Я приду только если придет Гена» или «Если там будет Марина, то меня там точно не будет».

Петя формализовал все требования в следующем виде: «[+-]name1 => [+-]name2», здесь «name1» и «name2» — имена двух друзей Пети, «+» означает, что друг придет в гости, «-» — что не придет. Например, выражение «Если Андрея не будет, то Даша не придет» записывается так: «-andrey => -dasha».

Помогите Пете составить хоть какой-нибудь список гостей, удовлетворяющий всем свойствам, или скажите, что это невозможно

__Входные данные__  
В первой строке входного файла записаны числа $n$ и $m$ — число друзей Пети и число условий $(1 ≤ n, m ≤ 1000)$. В следующих $n$ строках записаны имена друзей. Имена друзей состоят из маленьких латинских букв и имеют длину не больше $10$. В следующих $m$ строках записаны условия.

__Выходные данные__  
Выведите в первой строке число $k$ — число друзей, которых нужно пригласить. В следующих $k$ строках выведите их имена.

__Примерs__  
>__Входные данные__  
>3 3  
>vova  
>masha  
>gosha  
>-vova => -masha  
>-masha => +gosha  
>+gosha => +vova  
>__Выходные данные__  
>2  
>vova  
>masha  

>__Входные данные__  
>1 1  
>vova  
>-vova => +vova  
>__Выходные данные__  
>1  
>vova 

>__Входные данные__  
>2 4  
>vova  
>masha  
>+vova => +masha  
>+masha => -vova  
>-vova => -masha  
>-masha => +vova  
>__Выходные данные__  
>-1

***

## [Задча H](h.cpp). Авиаперелеты  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>  
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: avia.in  <br>
вывод: avia.out</i></p>

__Условие__  
Главного конструктора Петю попросили разработать новую модель самолета для компании «Air Бубундия». Оказалось, что самая сложная часть заключается в подборе оптимального размера топливного бака.

Главный картограф «Air Бубундия» Вася составил подробную карту Бубундии. На этой карте он отметил расход топлива для перелета между каждой парой городов.

Петя хочет сделать размер бака минимально возможным, для которого самолет сможет долететь от любого города в любой другой (возможно, с дозаправками в пути).

__Входные данные__  
Первая строка входного файла содержит натуральное число $n$ $(1 ≤ n ≤ 1000)$ — число городов в Бубундии.

Далее идут $n$ строк по $n$ чисел каждая. $j$-ое число в $i$-ой строке равно расходу топлива при перелете из $i$-ого города в $j$-ый. Все числа не меньше нуля и меньше $10^9$. Гарантируется, что для любого $i$ в $i$-ой строчке $i$-ое число равно нулю.

__Выходные данные__  
Первая строка выходного файла должна содержать одно число — оптимальный размер бака.

__Пример__  
>__Входные данные__  
>4  
>0 10 12 16  
>11 0 8 9  
>10 13 0 22  
>13 10 17 0  
>__Выходные данные__  
>10

***

## [Задча I](i.cpp). Остовное дерево  
<p align="center"><i>ограничение по времени на тест: 4 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>
__Условие__  
Даны точки на плоскости, являющиеся вершинами полного графа. Вес ребра равен расстоянию между точками, соответствующими концам этого ребра. Требуется в этом графе найти остовное дерево минимального веса.

__Входные данные__  
Первая строка входного файла содержит натуральное число $n$ — количество вершин графа $(1 ≤ n ≤ 10\ 000)$. Каждая из следующих $n$ строк содержит два целых числа $x_i$, $y_i$  — координаты $i$-й вершины $(-10\ 000 ≤ xi, yi ≤ 10\ 000)$. Никакие две точки не совпадают.

__Выходные данные__  
Первая строка выходного файла должна содержать одно вещественное число — вес минимального остовного дерева.

__Пример__  
>__Входные данные__  
>2  
>0 0  
>1 1  
>__Выходные данные__  
>1.4142135624

***

## [Задча J](j.cpp). Остовное дерево 2  
<p align="center"><i>ограничение по времени на тест: 2 секунды <br>
ограничение по памяти на тест: 256 мегабайт  <br>
ввод: стандартный ввод  <br>
вывод:стандартный вывод</i></p>
__Условие__  
Требуется найти в связном графе остовное дерево минимального веса.

__Входные данные__  
Первая строка входного файла содержит два натуральных числа $n$ и $m$ — количество вершин и ребер графа соответственно. Следующие m строк содержат описание ребер по одному на строке. Ребро номер $i$ описывается тремя натуральными числами $b_i$, $e_i$ и $w_i$ — номера концов ребра и его вес соответственно $(1 ≤ b_i, e_i ≤ n, 0 ≤ w_i ≤ 100\ 000)$. $n ≤ 200\ 000, m ≤ 200\ 000$.

Граф является связным.

__Выходные данные__  
Первая строка выходного файла должна содержать одно натуральное число — вес минимального остовного дерева.

__Пример__  
>__Входные данные__  
>4 4  
>1 2 1
>2 3 2
>3 4 5
>4 1 4 
>__Выходные данные__  
>7

